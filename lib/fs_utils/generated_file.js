// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var GeneratedFile, async, cachedTestFiles, common, debug, extractOrder, findTestFiles, flatten, fs, getTestFiles, loadTestFiles, sort, sortAlphabetically, sortByAfter, sortByBefore, sortByConfig, sortByVendor, sysPath,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  debug = require('debug')('brunch:generated-file');

  fs = require('fs');

  sysPath = require('path');

  async = require('async');

  common = require('./common');

  getTestFiles = function(config) {
    var files, isTestFile, joinPublic, joinTo;

    isTestFile = function(generatedFile) {
      return generatedFile.lastIndexOf(sysPath.normalize('test/'), 0) === 0 && generatedFile.lastIndexOf('vendor') === -1;
    };
    joinPublic = function(generatedFile) {
      return sysPath.join(config.paths["public"], generatedFile);
    };
    joinTo = config.files.javascripts.joinTo;
    files = typeof joinTo === 'string' ? [joinTo] : Object.keys(joinTo);
    return files.filter(isTestFile).map(joinPublic);
  };

  cachedTestFiles = null;

  findTestFiles = function(config) {
    return cachedTestFiles != null ? cachedTestFiles : cachedTestFiles = getTestFiles(config);
  };

  sortAlphabetically = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

  sortByVendor = function(config, a, b) {
    var aIsVendor, bIsVendor;

    aIsVendor = config.vendorConvention(a);
    bIsVendor = config.vendorConvention(b);
    if (aIsVendor && !bIsVendor) {
      return -1;
    } else if (!aIsVendor && bIsVendor) {
      return 1;
    } else {
      return sortAlphabetically(a, b);
    }
  };

  sortByAfter = function(config, a, b) {
    var hasA, hasB, indexOfA, indexOfB, _ref;

    indexOfA = config.after.indexOf(a);
    indexOfB = config.after.indexOf(b);
    _ref = [indexOfA !== -1, indexOfB !== -1], hasA = _ref[0], hasB = _ref[1];
    if (hasA && !hasB) {
      return 1;
    } else if (!hasA && hasB) {
      return -1;
    } else if (hasA && hasB) {
      return indexOfA - indexOfB;
    } else {
      return sortByVendor(config, a, b);
    }
  };

  sortByBefore = function(config, a, b) {
    var hasA, hasB, indexOfA, indexOfB, _ref;

    indexOfA = config.before.indexOf(a);
    indexOfB = config.before.indexOf(b);
    _ref = [indexOfA !== -1, indexOfB !== -1], hasA = _ref[0], hasB = _ref[1];
    if (hasA && !hasB) {
      return -1;
    } else if (!hasA && hasB) {
      return 1;
    } else if (hasA && hasB) {
      return indexOfA - indexOfB;
    } else {
      return sortByAfter(config, a, b);
    }
  };

  sortByConfig = function(files, config) {
    var cfg, _ref, _ref1, _ref2;

    if (toString.call(config) === '[object Object]') {
      cfg = {
        before: (_ref = config.before) != null ? _ref : [],
        after: (_ref1 = config.after) != null ? _ref1 : [],
        vendorConvention: (_ref2 = config.vendorConvention) != null ? _ref2 : function() {
          return false;
        }
      };
      return files.slice().sort(function(a, b) {
        return sortByBefore(cfg, a, b);
      });
    } else {
      return files;
    }
  };

  flatten = function(array) {
    return array.reduce(function(acc, elem) {
      return acc.concat(Array.isArray(elem) ? flatten(elem) : [elem]);
    }, []);
  };

  extractOrder = function(files, config) {
    var after, before, orders, types, vendorConvention;

    types = files.map(function(file) {
      return file.type + 's';
    });
    orders = Object.keys(config.files).filter(function(key) {
      return __indexOf.call(types, key) >= 0;
    }).map(function(key) {
      var _ref;

      return (_ref = config.files[key].order) != null ? _ref : {};
    });
    before = flatten(orders.map(function(type) {
      var _ref;

      return (_ref = type.before) != null ? _ref : [];
    }));
    after = flatten(orders.map(function(type) {
      var _ref;

      return (_ref = type.after) != null ? _ref : [];
    }));
    vendorConvention = config._normalized.conventions.vendor;
    return {
      before: before,
      after: after,
      vendorConvention: vendorConvention
    };
  };

  sort = function(files, config) {
    var indexes, order, paths;

    paths = files.map(function(file) {
      return file.path;
    });
    indexes = Object.create(null);
    files.forEach(function(file, index) {
      return indexes[file.path] = file;
    });
    order = extractOrder(files, config);
    return sortByConfig(paths, order).map(function(path) {
      return indexes[path];
    });
  };

  loadTestFiles = function(files, testsConvention) {
    return files.map(function(file) {
      return file.path;
    }).filter(function(path) {
      return testsConvention(path);
    }).map(function(path) {
      path = path.replace(RegExp('\\\\', 'g'), '/');
      return path.substring(0, path.lastIndexOf('.'));
    }).map(function(path) {
      return "window.require('" + path + "');";
    }).join('\n') + '\n';
  };

  module.exports = GeneratedFile = (function() {
    function GeneratedFile(path, sourceFiles, config, minifiers) {
      var _ref,
        _this = this;

      this.path = path;
      this.sourceFiles = sourceFiles;
      this.config = config;
      this.type = this.sourceFiles.some(function(file) {
        return file.type === 'javascript';
      }) ? 'javascript' : 'stylesheet';
      this.minifier = minifiers.filter(function(minifier) {
        return minifier.type === _this.type;
      })[0];
      this.isTestFile = (_ref = this.path, __indexOf.call(findTestFiles(this.config), _ref) >= 0);
      Object.freeze(this);
    }

    GeneratedFile.prototype._join = function(files, callback) {
      var joined, requireFiles,
        _this = this;

      debug("Joining files '" + (files.map(function(file) {
        return file.path;
      }).join(', ')) + "' to '" + this.path + "'");
      requireFiles = function() {
        return loadTestFiles(files, _this.config._normalized.conventions.tests);
      };
      joined = files.map(function(file) {
        return file.cache.data;
      }).join('');
      return process.nextTick(function() {
        var data;

        if (_this.type === 'javascript') {
          data = _this.config._normalized.modules.definition(_this.path, joined) + joined;
          return callback(null, (_this.isTestFile ? data + requireFiles() : data));
        } else {
          return callback(null, joined);
        }
      });
    };

    GeneratedFile.prototype._minify = function(data, callback) {
      var minify, _ref, _ref1, _ref2;

      if (this.config.optimize) {
        minify = (_ref = (_ref1 = this.minifier) != null ? _ref1.optimize : void 0) != null ? _ref : (_ref2 = this.minifier) != null ? _ref2.minify : void 0;
        return typeof minify === "function" ? minify(data, this.path, callback) : void 0;
      } else {
        return callback(null, data);
      }
    };

    GeneratedFile.prototype.write = function(callback) {
      var _this = this;

      return this._join(sort(this.sourceFiles, this.config), function(error, joined) {
        if (error != null) {
          return callback(error);
        }
        return _this._minify(joined, function(error, data) {
          if (error != null) {
            return callback(error);
          }
          return common.writeFile(_this.path, data, callback);
        });
      });
    };

    return GeneratedFile;

  })();

}).call(this);
